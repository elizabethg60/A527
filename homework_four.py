import numpy as np
import matplotlib.pyplot as plt
from A527_package import getAcc, getEnergy, leapFrog, RK4

"""
1. [40 Points] Write an N-body code to simulate the dynamics of the above system. The
code should calculate the pairwise gravitational forces, and solve the equations of motion
using Runge-Kutta 4th Order (RK4) method and the Leap-frog Kick-Drift-Kick algorithm for
comparison. Make sure to record at each time step the positions and velocities of the objects,
as well as the gravitational energy, kinetic energy, and total energy (sum of gravitational and
kinetic energy) of the system.
2. [30 Points] Apply the above code to the solar system to calculate the orbit of each
planet, using the initial conditions of the planets generated by NASA Horizons System
(https://ssd.jpl.nasa.gov/horizons/app.html#/). Simulate the system over a long pe-
riod of time (at least 1000 Earth years, with a timestep of 1 Earth day).
"""

method = 'RK4'

# Simulation parameters (cgs units)
dt = 86400  
Nt = 365 * 1000
# Required constants 
G = 6.6743e-11
au = 1.496e11

# Generate Initial Conditions
# taken from NASA planetary fact sheet
vel_system = np.array([0, 47.4e3, 35.0e3, 29.8e3, 24.1e3, 13.1e3, 9.7e3, 6.8e3, 5.4e3, 4.7e3])
masses = np.array([1.989e30, 3.3e23, 4.87e24, 5.97e24, 6.42e23, 1.898e27, 5.68e26, 8.68e25, 1.02e26, 1.3e22])
total_mass = np.sum(masses)
N = len(masses)    

# taken from windows to the universe
au_system = np.array([0, 0.3871 * au, 0.7233 * au, 1 * au, 1.5237 * au, 5.2028 * au, 9.5388 * au, 19.1914 * au, 30.0611 * au, 39.3 * au])
	
# Convert to Center-of-Mass frame
sun_initial_pos = -total_mass
sun_initial_vel = -total_mass
for i in range(1, len(masses)):
	sun_initial_pos += masses[i]*au_system[i]
	sun_initial_vel += masses[i]*vel_system[i]
sun_initial_pos /= masses[0]
sun_initial_vel /= masses[0]

# initial conditions
mass = np.array([[1.989e30], [3.3e23], [4.87e24], [5.97e24], [6.42e23], [1.898e27], [5.68e26], [8.68e25], [1.02e26], [1.3e22]])
pos = np.array([[sun_initial_pos, 0], [0.3871 * au, 0], [0.7233 * au, 0], [1 * au, 0], [1.5237 * au, 0], [5.2028 * au, 0], [9.5388 * au, 0], [19.1914 * au, 0], [30.0611 * au, 0], [39.3 * au, 0]])
vel = np.array([[0, sun_initial_vel], [0, 47.4e3], [0, 35.0e3], [0, 29.8e3], [0, 24.1e3], [0, 13.1e3], [0, 9.7e3], [0, 6.8e3], [0, 5.4e3], [0, 4.7e3]])
	
# calculate initial gravitational accelerations
acc = getAcc(pos, mass, G, N)
	
# calculate initial energy of system
KE, PE  = getEnergy(pos, vel, mass, G, N)
  
# save energies + orbits for plotting trails
pos_save = np.zeros((Nt+1, N, 2))
pos_save[0] = pos
KE_save = np.zeros(Nt+1)
KE_save[0] = KE
PE_save = np.zeros(Nt+1)
PE_save[0] = PE
t_all = np.arange(Nt+1)*dt	

# Simulation Main Loop
if method == 'LeapFrog':
    leapFrog(N, Nt, dt, pos, vel, acc, mass, G, KE_save, PE_save, pos_save)
if method == 'RK4':
    RK4(N, Nt, dt, pos, vel, mass, G, KE_save, PE_save, pos_save)

"""
3. Plot the orbits of the planets in the solar system, and the energies (kinetic,
gravitational, and total) of the system vs. time. You may create animations as well. Compare
the results using the RK4 and the Leapfrog methods. Which method is better and why?
"""

# Plot the orbits
for i in range(N):
	plt.plot(pos_save[:, i, 0], pos_save[:, i, 1])
plt.xlabel('X')
plt.ylabel('Y')
plt.gca().set_aspect('equal', adjustable='box')
plt.savefig("Figures/homework_four/orbit_{}".format(method))
plt.show()

# Plot the energies
plt.plot(t_all,KE_save/(10**35), color = 'r', label = 'KE')
plt.plot(t_all,PE_save/(10**35), color = 'b', label = 'PE')
plt.plot(t_all,(KE_save+PE_save)/(10**35), color = 'k', label = 'Total')
plt.xlabel('time')
plt.ylabel('energy')
plt.legend()
plt.savefig("Figures/homework_four/energy_{}".format(method))
plt.show()